<!DOCTYPE HTML>
<html>

<head>
	<meta charset="utf-8">
	<title>缓冲运动</title>
	<style>
		#div1 {
			width: 100px;
			height: 100px;
			background: red;
			position: absolute;
			left: 600px;
			top: 50px;
		}

		#div2 {
			width: 1px;
			height: 300px;
			position: absolute;
			left: 300px;
			top: 0;
			background: black;
		}
	</style>
	<script src="animation.js" type="text/javascript" charset="utf-8"></script>
	<script>
	/*	function startMove() {
			var oDiv = document.getElementById('div1');
			var timer = setInterval(function () {
				var speed = (300 - oDiv.offsetLeft) / 15;  //最终left为300px;  系数越大 运动越慢
				console.log(oDiv.offsetLeft);
				speed = speed > 0 ? Math.ceil(speed) : Math.floor(speed);
				oDiv.style.left = oDiv.offsetLeft + speed + 'px';
				document.title = oDiv.offsetLeft + ',' + speed;
				if(speed ==0 ){
					clearInterval(timer);
				}
			}, 30);
		}*/
		onload = function(){
			var shur = document.getElementsByTagName("input")[0];
			console.log(shur);
			var oDiv = document.getElementById('div1');
			shur.onclick = function(){
			/*	animation(oDiv,{height:30,width:10},1000,function(){
					animation(oDiv,{top:100,opacity:20},1000,function(){
						animation(oDiv,{top:500},1000,function(){
							animation(oDiv,{left:500})
						});
					});
				});*/
				
				animation(oDiv,{width:200,height:500,opacity:20},1000);
				animation(oDiv,{left:400,top:100},1000);
			}
		
		}
		
/*		 function animate(ele,options,callback){  
			 //还要保证不能同时调用两次animate函数 或者 必须保证当前animate未结束之前 不能再次调用
			if(ele.isOver) return;
			ele.isOver = true;
			for(var attr in options){  
				(function(attr){   //采用闭包函数 访问animate的内部变量 attr不再是外面的attr 而是传进来的attr
					var targetNum = options[attr];  //取出目标值  50
					ele[attr+"-timer"] = setInterval(function(){  //由于定时器是异步函数 所以会先执行for循环 以至于只有最后一个定时器生效
						//还要判断opacity属性 和 IE的兼容
						if(attr == "opacity"){
							var attrValue = getStyle(ele)[attr] * 100;
							var speed = (targetNum - attrValue)/8;
							speed = speed > 0? Math.ceil(speed):Math.floor(speed);
							ele.style.opacity = (attrValue + speed)/100;  
							ele.style.filter = "alpha(opacity="+(attrValue + speed) +")";  //IE兼容
						}else{
							var attrValue = parseInt(getStyle(ele)[attr]); //获取该属性当前的值
							var speed = (targetNum - attrValue)/8; //使速度是一个整数  speed可能等于0 
							speed = speed > 0? Math.ceil(speed):Math.floor(speed);
							ele.style[attr] = attrValue + speed + "px";
						}
						if( speed == 0 ){
							clearInterval(ele[attr+"-timer"]);
							if(isAllOver()){
								ele.isOver = false;
								callback?callback():"";
							}
							
						}
						console.log(speed);
					},30);
				})(attr);
			}
			
			//判断函数是否已经结束 实现动画效果 
			function isAllOver(){
				//判断属性值是否已经等于目标值
				var flag = true;
				for(var attr in options){
					var targetNum = options[attr];
					if(attr == "opacity"){
						if(getStyle(ele)[attr]*100 != targetNum){
							flag = false;
						}
					}else {
						if(parseInt(getStyle(ele)[attr]) != targetNum){
							flag = false;
						}
					}
				}
				//ele.isOver = false;
				return flag;
			}
			
		 }
		 function getStyle(ele){           //获得样式
		 if(ele.currentStyle){
		 	return ele.currentStyle;   //ie
		 }else{
		 	return getComputedStyle(ele,null);  //其他
		 }
		 }*/
	</script>
</head>

<body>
	<input type="button" value="开始运动"/>
	<div id="div1"></div>
	<div id="div2"></div>
</body>

</html>
